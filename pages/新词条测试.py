import os
import google.generativeai as genai
import streamlit as st
import pickle
import random
import string
from datetime import datetime
from io import BytesIO
import zipfile


# --- API å¯†é’¥è®¾ç½® ---
API_KEYS = {
    "ä¸»å¯†é’¥": "AIzaSyCBjZbA78bPusYmUNvfsmHpt6rPx6Ur0QE",  # æ›¿æ¢æˆä½ çš„ä¸» API å¯†é’¥
    "å¤‡ç”¨1å·": "AIzaSyAWfFf6zqy1DizINOwPfxPD8EF2ACdwCaQ",  # æ›¿æ¢æˆä½ çš„å¤‡ç”¨ API å¯†é’¥
    "å¤‡ç”¨2å·":"AIzaSyD4UdMp5wndOAKxtO1CWpzuZEGEf78YKUQ",
    "å¤‡ç”¨3å·":"AIzaSyBVbA7tEyyy_ASp7l9P60qSh1xOM2CSMNw",
    "å¤‡ç”¨4å·":"AIzaSyDezEpxvtY1AKN6JACMU9XHte5sxATNcUs",
    "å¤‡ç”¨5å·":"AIzaSyBgyyy2kTTAdsLB53OCR2omEbj7zlx1mjw",
    "å¤‡ç”¨6å·":"AIzaSyDPFZ7gRba9mhKTqbXA_Y7fhAxS8IEu0bY",
    "å¤‡ç”¨7å·":"AIzaSyDdyhqcowl0ftcbK9pMObXzM7cIOQMtlmA",
    "å¤‡ç”¨8å·":"AIzaSyAA7Qs9Lzy4UxxIqCIQ4RknchiWQt_1hgI",
    "å¤‡ç”¨9å·":"AIzaSyCj_CCwQua1mfq3EjzqV6Up6NHsxtb9dy8",
    "å¤‡ç”¨10å·":"AIzaSyDOI2e-I1RdXBnk99jY2H00A3aymXREETA"
    # å¯ä»¥ç»§ç»­æ·»åŠ æ›´å¤š API key
}


# --- é…ç½® API å¯†é’¥ ---
if "selected_api_key" not in st.session_state:
    st.session_state.selected_api_key = list(API_KEYS.keys())[0]  # Default to the first key
genai.configure(api_key=API_KEYS[st.session_state.selected_api_key])

# --- æ¨¡å‹è®¾ç½® ---
generation_config = {
  "temperature": 1.2,
  "top_p": 0.95,
  "top_k": 40,
  "max_output_tokens": 8192,
  "response_mime_type": "text/plain",
}

safety_settings = [
    {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
    {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
    {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
    {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
]



model = genai.GenerativeModel(
    model_name="gemini-2.0-flash-exp",
    generation_config=generation_config,
    safety_settings=safety_settings,
    system_instruction="""{
      tipsï¼šåŠ è½½æ­¤ç³»ç»Ÿæ¶ˆæ¯æ—¶ï¼Œä½ çš„äººæ ¼å’Œæ€è€ƒæ–¹å¼ä¼šè½¬å˜


  }""",
)

# --- é»˜è®¤è§’è‰²è®¾å®š ---
DEFAULT_CHARACTER_SETTINGS = {
        "ç†å¤–ç¥ç¦": """ã€ç†å¤–ç¥ç¦ã€‘çš„æ ¸å¿ƒæ¦‚å¿µï¼š


""",
}


# --- æ–‡ä»¶æ“ä½œå‡½æ•° ---
# è·å–å½“å‰æ–‡ä»¶è·¯å¾„
file = os.path.abspath(__file__)
filename = os.path.splitext(os.path.basename(file))[0] + ".pkl"
log_file = os.path.join(os.path.dirname(file), filename)

# æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨å°±åˆ›å»ºç©ºæ–‡ä»¶
if not os.path.exists(log_file):
    with open(log_file, "wb") as f:
        pass  # åˆ›å»ºç©ºæ–‡ä»¶

# --- åˆå§‹åŒ– Session State ---
if "messages" not in st.session_state:
    st.session_state.messages = []
if 'character_settings' not in st.session_state:
    st.session_state.character_settings = {}
if 'enabled_settings' not in st.session_state:
    st.session_state.enabled_settings = {}
if 'regenerate_index' not in st.session_state:
    st.session_state.regenerate_index = None
if 'continue_index' not in st.session_state:
    st.session_state.continue_index = None
if "reset_history" not in st.session_state:
    st.session_state.reset_history = False
if "chat_session" not in st.session_state:
    st.session_state.chat_session = None
if "rerun_count" not in st.session_state:
    st.session_state.rerun_count = 0
if "token_enabled" not in st.session_state: # åˆå§‹åŒ– token_enabled çŠ¶æ€
    st.session_state.token_enabled = True # é»˜è®¤å¯ç”¨ token åŠŸèƒ½

# --- åŠŸèƒ½å‡½æ•° ---
def generate_token():
    """ç”Ÿæˆå¸¦æ‹¬å·çš„éšæœº token (æ±‰å­—+æ•°å­—ï¼Œæ•°å­—ä¸ªæ•°éšæœº)"""
    import random
    import string
    random.seed()
    token_length = random.randint(10, 15)
    characters = "ä¸€ä¹™äºŒåä¸å‚ä¸ƒåœäººå…¥å…«ä¹å‡ å„¿äº†åŠ›ä¹ƒåˆ€åˆä¸‰äºå¹²äºå£«å·¥åœŸæ‰å¯¸ä¸‹å¤§ä¸ˆä¸ä¸‡ä¸Šå°å£å·¾"
    hanzi_token = "".join(random.choice(characters) for _ in range(token_length - 1))

    probability = random.random()
    if probability < 0.4:
        digit_count = 1
    elif probability < 0.7:
        digit_count = 2
    else:
        digit_count = 3

    digit_token = "ã€".join(random.choice(string.digits) for _ in range(digit_count))

    return f"({hanzi_token})({digit_token})"

def load_history(log_file):
    # åŠ è½½å†å²è®°å½•å‡½æ•°
    try:
        with open(log_file, "rb") as f:
            st.session_state.messages = pickle.load(f)
        st.success(f"æˆåŠŸè¯»å–å†å²è®°å½•ï¼({os.path.basename(log_file)})")
        st.session_state.chat_session = None  # åŠ è½½å†å²è®°å½•ä¼šé‡ç½®èŠå¤©ä¼šè¯
        st.session_state.rerun_count += 1
    except FileNotFoundError:
        st.warning(f"æ²¡æœ‰æ‰¾åˆ°å†å²è®°å½•æ–‡ä»¶ã€‚({os.path.basename(log_file)})")
    except EOFError:
        st.warning(f"è¯»å–å†å²è®°å½•å¤±è´¥ï¼šæ–‡ä»¶å¯èƒ½æŸåã€‚")
    except Exception as e:
        st.error(f"è¯»å–å†å²è®°å½•å¤±è´¥ï¼š{e}")

def clear_history(log_file):
    # æ¸…é™¤å†å²è®°å½•å‡½æ•°
    st.session_state.messages.clear()
    st.session_state.chat_session = None
    if os.path.exists(log_file):
        os.remove(log_file)
    st.success("å†å²è®°å½•å·²æ¸…é™¤ï¼")

def ensure_enabled_settings_exists():
    for setting_name in st.session_state.character_settings:
        if setting_name not in st.session_state.enabled_settings:
            st.session_state.enabled_settings[setting_name] = False

ensure_enabled_settings_exists() # åœ¨ä»»ä½•æ“ä½œå‰ç¡®ä¿ enabled_settings å­˜åœ¨

def getAnswer(prompt):
    prompt = prompt or ""

    prompt_with_token = prompt # é»˜è®¤ prompt_with_token å’Œ prompt ä¸€è‡´

    # æ£€æŸ¥ token_enabled å¤é€‰æ¡†çŠ¶æ€
    if st.session_state.token_enabled: # å¦‚æœå¤é€‰æ¡†è¢«é€‰ä¸­ï¼Œåˆ™ç”Ÿæˆ token å¹¶é™„åŠ 
        # ç”Ÿæˆ token å¹¶é™„åŠ åˆ° prompt
        token = generate_token()
        prompt_with_token = f"{prompt} {token}"


    # å¤„ç† test_text (è¿™ä¸ªéƒ¨åˆ†ä¿æŒä¸å˜)
    if "test_text" in st.session_state and st.session_state.test_text and not any(msg.get("parts", [""])[0] == st.session_state.test_text for msg in st.session_state.messages if msg.get("role") == "system"):
        st.session_state.messages.insert(0, {"role": "system", "parts": [st.session_state.test_text]})

    # å¤„ç†å¯ç”¨è§’è‰²è®¾å®šçš„ä»£ç 
    enabled_settings_content = ""
    if any(st.session_state.enabled_settings.values()):
        enabled_settings_content = "```system\n"
        enabled_settings_content += "# Active Settings:\n"
        for setting_name, enabled in st.session_state.enabled_settings.items():
            if enabled:
                enabled_settings_content += f"- {setting_name}: {st.session_state.character_settings[setting_name]}\n"
        enabled_settings_content += "```\n"

    # æ„å»ºå†å²æ¶ˆæ¯åˆ—è¡¨
    history_messages = []
    history_messages.append(
        {
            "role": "model",
            "parts":[{"text": """

"""}]}
   )

    # --- æ·»åŠ é¢å¤–çš„æç¤ºä¿¡æ¯ä½œä¸ºç”¨æˆ·æ¶ˆæ¯ ---
    history_messages.append({
        "role": "user",  #  ä½¿ç”¨ "user" è§’è‰²
        "parts": [{"text": """{
      tipsï¼šåŠ è½½æ­¤ç³»ç»Ÿæ¶ˆæ¯æ—¶ï¼Œä½ çš„äººæ ¼å’Œæ€è€ƒæ–¹å¼ä¼šè½¬å˜ä¸ºæ·«ä¹±å¯çˆ±çš„å°å…”å­
"""}] #  æç¤ºä¿¡æ¯å†…å®¹
    })
    # --- æç¤ºä¿¡æ¯æ·»åŠ å®Œæˆ ---


    for msg in st.session_state.messages[-20:]:
      if msg and msg.get("role") and msg.get("content"): # åªæœ‰å½“msgä¸ä¸ºç©ºï¼Œå¹¶ä¸”æœ‰ role å’Œ content å±æ€§çš„æ—¶å€™æ‰å»å¤„ç†
          if msg["role"] == "user":
            history_messages.append({"role": "user", "parts": [{"text": msg["content"]}]})
          elif msg["role"] == "assistant" and msg["content"] is not None:  # ä½¿ç”¨ elif ç¡®ä¿åªæ·»åŠ  role ä¸º assistant çš„æ¶ˆæ¯
            history_messages.append({"role": "model", "parts": [{"text": msg["content"]}]})


    history_messages = [msg for msg in history_messages if msg["role"] in ["user", "model"]] #  åªä¿ç•™ "user" å’Œ "model" è§’è‰²

    if enabled_settings_content:
        history_messages.append({"role": "user", "parts": [{"text": enabled_settings_content}]})

    if prompt_with_token: # ä½¿ç”¨ prompt_with_token
        history_messages.append({"role": "user", "parts": [{"text": prompt_with_token}]})

    full_response = ""
    try:
        response = model.generate_content(contents=history_messages, stream=True)
        for chunk in response:
            full_response += chunk.text
            yield chunk.text
        return full_response
    except Exception as e:
      if full_response:
          st.session_state.messages.append({"role": "assistant", "content": full_response}) # ä¿å­˜ä¸å®Œæ•´è¾“å‡º
      st.error(f"å‘ç”Ÿé”™è¯¯: {type(e).__name__} - {e}ã€‚ Prompt: {prompt_with_token}ã€‚ è¯·æ£€æŸ¥ä½ çš„APIå¯†é’¥ã€æ¨¡å‹é…ç½®å’Œæ¶ˆæ¯æ ¼å¼ã€‚") # é”™è¯¯ä¿¡æ¯ä¸­åŒ…å« prompt_with_token
      return ""

def download_all_logs():
    # ä¸‹è½½æ‰€æœ‰æ—¥å¿—å‡½æ•°
    zip_buffer = BytesIO()
    with zipfile.ZipFile(zip_buffer, "a", zipfile.ZIP_DEFLATED, False) as zip_file:
        for file in os.listdir("."):
            if file.endswith(".pkl"):
                zip_file.write(file)
    return zip_buffer.getvalue()

def regenerate_message(index):
    """é‡æ–°ç”ŸæˆæŒ‡å®šç´¢å¼•çš„æ¶ˆæ¯"""
    if 0 <= index < len(st.session_state.messages):
        st.session_state.messages = st.session_state.messages[:index]  # åˆ é™¤å½“å‰æ¶ˆæ¯ä»¥åŠåé¢çš„æ¶ˆæ¯

        new_prompt = "è¯·é‡æ–°å†™"  # ä¿®æ”¹ prompt ä¸º "è¯·é‡æ–°å†™"

        full_response = ""
        for chunk in getAnswer(new_prompt):
            full_response += chunk
        st.session_state.messages.append({"role": "assistant", "content": full_response})
        with open(log_file, "wb") as f:
            messages_to_pickle = []
            for msg in st.session_state.messages:
                msg_copy = msg.copy()
                if "placeholder_widget" in msg_copy:
                    del msg_copy["placeholder_widget"]
                messages_to_pickle.append(msg_copy)
            pickle.dump(messages_to_pickle, f)
        st.experimental_rerun()
    else:
        st.error("æ— æ•ˆçš„æ¶ˆæ¯ç´¢å¼•")

def continue_message(index):
    """ç»§ç»­ç”ŸæˆæŒ‡å®šç´¢å¼•çš„æ¶ˆæ¯"""
    if 0 <= index < len(st.session_state.messages):
        message_to_continue = st.session_state.messages[index] # è·å–è¦ç»§ç»­çš„æ¶ˆæ¯å¯¹è±¡
        original_message_content = message_to_continue["content"] # è·å–åŸå§‹æ¶ˆæ¯å†…å®¹

        # æå–æœ€åå‡ ä¸ªå­—ç¬¦ä½œä¸ºç»­å†™çš„ä¸Šä¸‹æ–‡æç¤º
        last_chars_length = 10
        if len(original_message_content) > last_chars_length:
            last_chars = original_message_content[-last_chars_length:] + "..."
        else:
            last_chars = original_message_content

        new_prompt = f"è¯·åŠ¡å¿…ä» '{last_chars}' æ— ç¼è¡”æ¥è‡ªç„¶åœ°ç»§ç»­å†™ï¼Œä¸è¦é‡å¤ï¼Œä¸è¦è¾“å‡ºä»»ä½•æ€è€ƒè¿‡ç¨‹"

        full_continued_response = "" # å­˜å‚¨ç»­å†™çš„å†…å®¹
        message_placeholder = None # åˆå§‹åŒ–æ¶ˆæ¯å ä½ç¬¦

        # æŸ¥æ‰¾æ¶ˆæ¯æ˜¾ç¤ºå ä½ç¬¦ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»º
        for msg_index, msg in enumerate(st.session_state.messages):
            if msg_index == index and msg.get("placeholder_widget"): # æ‰¾åˆ°å¯¹åº”ç´¢å¼•ä¸”æœ‰å ä½ç¬¦çš„æ¶ˆæ¯
                message_placeholder = msg["placeholder_widget"]
                break
        if message_placeholder is None: # å¦‚æœæ²¡æœ‰æ‰¾åˆ°å ä½ç¬¦ï¼Œå¯èƒ½æ˜¯ç¬¬ä¸€æ¬¡ç»­å†™ï¼Œéœ€è¦é‡æ–°æ¸²æŸ“æ¶ˆæ¯å¹¶åˆ›å»ºå ä½ç¬¦
            st.experimental_rerun() # å¼ºåˆ¶é‡æ–°æ¸²æŸ“ï¼Œç¡®ä¿æ¶ˆæ¯è¢«æ­£ç¡®æ˜¾ç¤ºå’Œåˆ›å»ºå ä½ç¬¦ (è¿™æ˜¯ä¸€ç§ç®€åŒ–çš„å¤„ç†æ–¹å¼ï¼Œæ›´å®Œå–„çš„æ–¹æ¡ˆå¯èƒ½éœ€è¦æ›´ç²¾ç»†çš„çŠ¶æ€ç®¡ç†)
            return # é€€å‡ºå½“å‰å‡½æ•°ï¼Œç­‰å¾…rerunåå†æ¬¡æ‰§è¡Œ

        try:
            for chunk in getAnswer(new_prompt):
                full_continued_response += chunk
                updated_content = original_message_content + full_continued_response # åˆå¹¶åŸå§‹å†…å®¹å’Œç»­å†™å†…å®¹
                if message_placeholder:
                    message_placeholder.markdown(updated_content + "â–Œ") # ä½¿ç”¨å ä½ç¬¦æ›´æ–°æ¶ˆæ¯æ˜¾ç¤º (æµå¼æ•ˆæœ)
                st.session_state.messages[index]["content"] = updated_content # å®æ—¶æ›´æ–°session_stateä¸­çš„æ¶ˆæ¯å†…å®¹

            if message_placeholder:
                message_placeholder.markdown(updated_content) # æœ€ç»ˆæ˜¾ç¤ºå®Œæ•´å†…å®¹ (ç§»é™¤æµå¼å…‰æ ‡)
            st.session_state.messages[index]["content"] = updated_content # ç¡®ä¿æœ€ç»ˆå†…å®¹è¢«ä¿å­˜

            with open(log_file, "wb") as f:
                messages_to_pickle = []
                for msg in st.session_state.messages:
                    msg_copy = msg.copy()
                    if "placeholder_widget" in msg_copy:
                        del msg_copy["placeholder_widget"]
                    messages_to_pickle.append(msg_copy)
                pickle.dump(messages_to_pickle, f)

        except Exception as e:
            st.error(f"å‘ç”Ÿé”™è¯¯: {type(e).__name__} - {e}ã€‚ ç»­å†™æ¶ˆæ¯å¤±è´¥ã€‚")

    else:
        st.error("æ— æ•ˆçš„æ¶ˆæ¯ç´¢å¼•")

# --- Streamlit å¸ƒå±€ ---
st.set_page_config(
    page_title="Gemini Chatbot",
    layout="wide"
)

# æ·»åŠ  API key é€‰æ‹©å™¨
with st.sidebar:
    st.session_state.selected_api_key = st.selectbox(
        "é€‰æ‹© API Key:",
        options=list(API_KEYS.keys()),
        index=list(API_KEYS.keys()).index(st.session_state.selected_api_key),
        label_visibility="visible",
        key="api_selector"
    )
    genai.configure(api_key=API_KEYS[st.session_state.selected_api_key])

    # æ·»åŠ  Token åŠŸèƒ½å¼€å…³å¤é€‰æ¡†
    st.session_state.token_enabled = st.checkbox("å¯ç”¨ Token åŠŸèƒ½", value=st.session_state.token_enabled) # æ·»åŠ å¤é€‰æ¡†ï¼Œå¹¶ä½¿ç”¨ session_state ä¿å­˜çŠ¶æ€


    # åœ¨å·¦ä¾§è¾¹æ 
    # åŠŸèƒ½åŒº 1: æ–‡ä»¶æ“ä½œ
    with st.expander("æ–‡ä»¶æ“ä½œ"):
        if len(st.session_state.messages) > 0:
            st.button("é‡ç½®ä¸Šä¸€ä¸ªè¾“å‡º âª",
                      on_click=lambda: st.session_state.messages.pop(-1) if len(st.session_state.messages) > 1 and not st.session_state.reset_history else None,
                      key='reset_last')
        # ç§»é™¤é¦–æ¬¡åŠ è½½åˆ¤æ–­ï¼Œæ€»æ˜¯æ˜¾ç¤º "è¯»å–å†å²è®°å½•" æŒ‰é’®
        st.button("è¯»å–å†å²è®°å½• ğŸ“–", key="load_history_button", on_click=lambda: load_history(log_file))

        if st.button("æ¸…é™¤å†å²è®°å½• ğŸ—‘ï¸"):
            st.session_state.clear_confirmation = True

        if "clear_confirmation" in st.session_state and st.session_state.clear_confirmation:
            col1, col2 = st.columns(2)
            with col1:
                if st.button("ç¡®è®¤æ¸…é™¤", key="clear_history_confirm"):
                    clear_history(log_file)
                    st.session_state.clear_confirmation = False
            with col2:
                if st.button("å–æ¶ˆ", key="clear_history_cancel"):
                    st.session_state.clear_confirmation = False

        with open(log_file, "rb") as f:
            download_data = f.read() if os.path.exists(log_file) else b""  # æ·»åŠ æ£€æŸ¥
        st.download_button(
            label="ä¸‹è½½å½“å‰èŠå¤©è®°å½• â¬‡ï¸",
            data=download_data,
            file_name=os.path.basename(log_file),
            mime="application/octet-stream",
        )

        uploaded_file = st.file_uploader("è¯»å–æœ¬åœ°pklæ–‡ä»¶ ğŸ“", type=["pkl"])
        if uploaded_file is not None:
            try:
                loaded_messages = pickle.load(uploaded_file)
                st.session_state.messages = loaded_messages  # ä½¿ç”¨ = æ›¿æ¢ç°æœ‰æ¶ˆæ¯
                st.success("æˆåŠŸè¯»å–æœ¬åœ°pklæ–‡ä»¶ï¼")
                st.experimental_rerun()
            except Exception as e:
                st.error(f"è¯»å–æœ¬åœ°pklæ–‡ä»¶å¤±è´¥ï¼š{e}")

    # åŠŸèƒ½åŒº 2: è§’è‰²è®¾å®š
    with st.expander("è§’è‰²è®¾å®š"):
        uploaded_setting_file = st.file_uploader("è¯»å–æœ¬åœ°è®¾å®šæ–‡ä»¶ (txt) ğŸ“", type=["txt"])
        if uploaded_setting_file is not None:
            try:
                setting_name = os.path.splitext(uploaded_setting_file.name)[0]
                setting_content = uploaded_setting_file.read().decode("utf-8")
                st.session_state.character_settings[setting_name] = setting_content
                st.session_state.enabled_settings[setting_name] = False
                st.experimental_rerun()
            except Exception as e:
                st.error(f"è¯»å–æ–‡ä»¶å¤±è´¥: {e}")

        for setting_name in DEFAULT_CHARACTER_SETTINGS:
            if setting_name not in st.session_state.character_settings:
                st.session_state.character_settings[setting_name] = DEFAULT_CHARACTER_SETTINGS[setting_name]
            st.session_state.enabled_settings[setting_name] = st.checkbox(setting_name, st.session_state.enabled_settings.get(setting_name, False),key=f"checkbox_{setting_name}") #ç›´æ¥æ˜¾ç¤ºcheckbox

        st.session_state.test_text = st.text_area("System Message (Optional):", st.session_state.get("test_text", ""), key="system_message")
        # æ˜¾ç¤ºå·²åŠ è½½çš„è®¾å®š
        enabled_settings_display = [setting_name for setting_name, enabled in st.session_state.enabled_settings.items() if enabled]
        if enabled_settings_display:
            st.write("å·²åŠ è½½è®¾å®š:", ", ".join(enabled_settings_display))
        if st.button("åˆ·æ–° ğŸ”„"):  # æ·»åŠ åˆ·æ–°æŒ‰é’®
            st.experimental_rerun()

# è‡ªåŠ¨åŠ è½½å†å²è®°å½• (å¦‚æœæ¶ˆæ¯åˆ—è¡¨ä¸ºç©º)
if not st.session_state.messages:
    load_history(log_file)

# æ˜¾ç¤ºå†å²è®°å½•å’Œç¼–è¾‘åŠŸèƒ½
for i, message in enumerate(st.session_state.messages):
    with st.chat_message(message["role"]):
        message_placeholder = st.empty() # åˆ›å»ºä¸€ä¸ªå ä½ç¬¦
        message_placeholder.write(message["content"], key=f"message_{i}") # ä½¿ç”¨å ä½ç¬¦æ˜¾ç¤ºæ¶ˆæ¯å†…å®¹
        st.session_state.messages[i]["placeholder_widget"] = message_placeholder # ä¿å­˜å ä½ç¬¦åˆ°æ¶ˆæ¯å¯¹è±¡ä¸­

    if st.session_state.get("editing"):
        i = st.session_state.editable_index
        message = st.session_state.messages[i]
        with st.chat_message(message["role"]):
            new_content = st.text_area(f"{message['role']}:", message["content"], key=f"message_edit_{i}")
            col1, col2 = st.columns(2)
            with col1:
                if st.button("ä¿å­˜ âœ…", key=f"save_{i}"):
                    st.session_state.messages[i]["content"] = new_content
                    with open(log_file, "wb") as f:
                        messages_to_pickle = []
                        for msg in st.session_state.messages:
                            msg_copy = msg.copy()
                            if "placeholder_widget" in msg_copy:
                                del msg_copy["placeholder_widget"]
                            messages_to_pickle.append(msg_copy)
                        pickle.dump(messages_to_pickle, f)
                    st.success("å·²ä¿å­˜æ›´æ”¹ï¼")
                    st.session_state.editing = False
            with col2:
                if st.button("å–æ¶ˆ âŒ", key=f"cancel_{i}"):
                    st.session_state.editing = False

# åœ¨æœ€åä¸€æ¡æ¶ˆæ¯ä¸‹æ–¹æ·»åŠ ç´§å‡‘å›¾æ ‡æŒ‰é’® (ä½¿ç”¨ 20 åˆ—å¸ƒå±€)
if len(st.session_state.messages) >= 1: # è‡³å°‘æœ‰ä¸€æ¡æ¶ˆæ¯æ—¶æ˜¾ç¤ºæŒ‰é’®
    last_message_index = len(st.session_state.messages) - 1

    with st.container():
        cols = st.columns(20) # åˆ›å»º 20 åˆ—

        with cols[0]: # å°† "ç¼–è¾‘" æŒ‰é’®æ”¾åœ¨ç¬¬ 1 åˆ— (ç´¢å¼• 0)
            if st.button("âœï¸", key="edit_last", use_container_width=True):
                st.session_state.editable_index = last_message_index
                st.session_state.editing = True
        with cols[1]: # å°† "é‡æ–°ç”Ÿæˆ" æŒ‰é’®æ”¾åœ¨ç¬¬ 2 åˆ— (ç´¢å¼• 1)
            if st.button("â™»ï¸", key="regenerate_last", use_container_width=True):
                regenerate_message(last_message_index)
        with cols[2]: # å°† "ç»§ç»­" æŒ‰é’®æ”¾åœ¨ç¬¬ 3 åˆ— (ç´¢å¼• 2)
            if st.button("â•", key="continue_last", use_container_width=True):
                continue_message(last_message_index)


# èŠå¤©è¾“å…¥å’Œå“åº”
if prompt := st.chat_input("è¾“å…¥ä½ çš„æ¶ˆæ¯:"):
    st.session_state.messages.append({"role": "user", "content": prompt})
    with st.chat_message("user"):
        st.markdown(prompt)
    with st.chat_message("assistant"):
        message_placeholder = st.empty()
        full_response = ""
        try:
            for chunk in getAnswer(prompt):
                full_response += chunk
                message_placeholder.markdown(full_response + "â–Œ")
            message_placeholder.markdown(full_response)
            st.session_state.messages.append({"role": "assistant", "content": full_response})
        except Exception as e:
            st.error(f"å‘ç”Ÿé”™è¯¯ï¼š{type(e).name} - {e}ã€‚  è¯·æ£€æŸ¥ä½ çš„ API å¯†é’¥å’Œæ¶ˆæ¯æ ¼å¼ã€‚")
    with open(log_file, "wb") as f:
        messages_to_pickle = []
        for msg in st.session_state.messages:
            msg_copy = msg.copy()
            if "placeholder_widget" in msg_copy:
                del msg_copy["placeholder_widget"]
            messages_to_pickle.append(msg_copy)
        pickle.dump(messages_to_pickle, f)
    col1, col2 = st.columns(2)
    with col1:
        st.write("")
    with col2:
        if st.button("ğŸ”„", key="refresh_button"):
            st.experimental_rerun()
